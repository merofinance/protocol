// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "../../interfaces/IController.sol";
import "../../interfaces/tokenomics/IKeeperGauge.sol";

import "../../libraries/ScaledMath.sol";
import "../../libraries/Errors.sol";
import "../../libraries/AddressProviderHelpers.sol";
import "../../libraries/UncheckedMath.sol";

import "../access/Authorization.sol";

contract KeeperGauge is IKeeperGauge, Authorization {
    using AddressProviderHelpers for IAddressProvider;
    using ScaledMath for uint256;
    using UncheckedMath for uint256;

    struct KeeperRecord {
        mapping(uint256 => uint256) feesInPeriod;
        uint256 nextEpochToClaim;
        bool firstEpochSet;
    }

    mapping(address => KeeperRecord) public keeperRecords;
    mapping(uint256 => uint256) public perPeriodTotalFees;

    IAddressProvider public immutable addressProvider;
    address public immutable pool;
    uint256 public epoch;

    uint48 public lastUpdated;
    mapping(uint256 => uint256) public perPeriodTotalInflation;

    bool public override killed;

    event Killed();

    constructor(IAddressProvider _addressProvider, address _pool)
        Authorization(_addressProvider.getRoleManager())
    {
        addressProvider = _addressProvider;
        pool = _pool;
        lastUpdated = uint48(block.timestamp);
    }

    /**
     * @notice Shut down the gauge.
     * @dev Accrued inflation can still be claimed from the gauge after shutdown.
     */
    function kill() external override onlyRole(Roles.INFLATION_MANAGER) {
        poolCheckpoint();
        epoch = epoch.uncheckedInc();
        killed = true;
        emit Killed();
    }

    /**
     * @notice Report fees generated by a keeper (this is the basis for inflation accrual).
     * @dev lpTokenAddress is included for forward compatibility with a single gauge solution.
     * @param beneficiary Address of the keeper who earned the fees.
     * @param amount Amount of fees (in lp tokens) earned.
     * @param lpTokenAddress Address of the lpToken in which the fees are paid.
     */
    function reportFees(
        address beneficiary,
        uint256 amount,
        address lpTokenAddress
    ) external override {
        lpTokenAddress; // silencing compiler warning
        require(addressProvider.isWhiteListedFeeHandler(msg.sender), Error.ADDRESS_NOT_WHITELISTED);
        require(!killed, Error.CONTRACT_PAUSED);
        if (!keeperRecords[beneficiary].firstEpochSet) {
            keeperRecords[beneficiary].firstEpochSet = true;
            keeperRecords[beneficiary].nextEpochToClaim = epoch;
        }
        keeperRecords[beneficiary].feesInPeriod[epoch] += amount;
        perPeriodTotalFees[epoch] += amount;
    }

    /**
     * @notice Advance the inflation accrual epoch.
     */
    function advanceEpoch() external virtual override onlyRole(Roles.INFLATION_MANAGER) {
        require(!killed, Error.CONTRACT_PAUSED);
        poolCheckpoint();
        epoch = epoch.uncheckedInc();
    }

    function claimRewards(address beneficiary) external override returns (uint256) {
        return claimRewards(beneficiary, epoch);
    }

    function poolCheckpoint(uint256 updateEndTime)
        external
        override
        onlyRole(Roles.INFLATION_MANAGER)
        returns (bool)
    {
        uint256 timeElapsed = updateEndTime - uint256(lastUpdated);
        _poolCheckpoint(timeElapsed);
        lastUpdated = uint48(updateEndTime);
        return true;
    }

    function claimableRewards(address beneficiary) external view override returns (uint256) {
        return _calcTotalClaimable(beneficiary, keeperRecords[beneficiary].nextEpochToClaim, epoch);
    }

    function poolCheckpoint() public override returns (bool) {
        if (killed) return false;
        addressProvider.getInflationManager().checkPointInflation();
        uint256 timeElapsed = block.timestamp - uint256(lastUpdated);
        _poolCheckpoint(timeElapsed);
        lastUpdated = uint48(block.timestamp);
        return true;
    }

    /**
     * @notice Claim rewards with an epoch up to which they should be claimed specified.
     * @param beneficiary Address to claim rewards for.
     * @param endEpoch Epoch up to which to claim rewards.
     * @return The amount of rewards claimed.
     */
    function claimRewards(address beneficiary, uint256 endEpoch) public override returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        if (endEpoch > epoch) {
            endEpoch = epoch;
        }

        uint256 totalClaimable = _calcTotalClaimable(
            beneficiary,
            keeperRecords[beneficiary].nextEpochToClaim,
            endEpoch
        );
        keeperRecords[beneficiary].nextEpochToClaim = endEpoch;
        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED);
        _mintRewards(beneficiary, totalClaimable);

        return totalClaimable;
    }

    function _poolCheckpoint(uint256 timeElapsed) internal {
        uint256 currentRate = addressProvider.getInflationManager().getKeeperRateForPool(pool);
        perPeriodTotalInflation[epoch] += currentRate * timeElapsed;
    }

    function _mintRewards(address beneficiary, uint256 amount) internal {
        addressProvider.getInflationManager().mintRewards(beneficiary, amount);
    }

    function _calcTotalClaimable(
        address beneficiary,
        uint256 startEpoch,
        uint256 endEpoch
    ) internal view returns (uint256) {
        uint256 totalClaimable;
        for (uint256 i = startEpoch; i < endEpoch; i = i.uncheckedInc()) {
            uint256 periodTotalFees = perPeriodTotalFees[i];
            if (periodTotalFees > 0) {
                totalClaimable += (
                    keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(periodTotalFees)
                ).scaledMul(perPeriodTotalInflation[i]);
            }
        }
        return totalClaimable;
    }
}
